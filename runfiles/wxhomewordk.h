// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: src/main/proto/wxhomework.proto
#ifndef GRPC_src_2fmain_2fproto_2fwxhomework_2eproto__INCLUDED
#define GRPC_src_2fmain_2fproto_2fwxhomework_2eproto__INCLUDED

#include "src/main/proto/wxhomework.pb.h"

#include <functional>
#include <grpcpp/impl/codegen/async_generic_service.h>
#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/method_handler_impl.h>
#include <grpcpp/impl/codegen/proto_utils.h>
#include <grpcpp/impl/codegen/rpc_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/status.h>
#include <grpcpp/impl/codegen/stub_options.h>
#include <grpcpp/impl/codegen/sync_stream.h>

namespace grpc_impl {
	class CompletionQueue;
	class ServerCompletionQueue;
	class ServerContext;
}  // namespace grpc_impl

namespace grpc {
	namespace experimental {
		template <typename RequestT, typename ResponseT>
		class MessageAllocator;
	}  // namespace experimental
}  // namespace grpc

namespace wxhomework {

// 笑话Service——学生通过情绪认证后页面展示的内容
	class JokeService final {
		public:
			static constexpr char const* service_full_name() {
				return "wxhomework.JokeService";
			}
			class StubInterface {
				public:
					virtual ~StubInterface() {}
					virtual ::grpc::Status doGetJoke(::grpc::ClientContext* context, const ::wxhomework::JokeRequest& request, ::wxhomework::JokeResponse* response) = 0;
					std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::wxhomework::JokeResponse>> AsyncdoGetJoke(::grpc::ClientContext* context, const ::wxhomework::JokeRequest& request, ::grpc::CompletionQueue* cq) {
						return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::wxhomework::JokeResponse>>(AsyncdoGetJokeRaw(context, request, cq));
					}
					std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::wxhomework::JokeResponse>> PrepareAsyncdoGetJoke(::grpc::ClientContext* context, const ::wxhomework::JokeRequest& request, ::grpc::CompletionQueue* cq) {
						return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::wxhomework::JokeResponse>>(PrepareAsyncdoGetJokeRaw(context, request, cq));
					}
					class experimental_async_interface {
						public:
							virtual ~experimental_async_interface() {}
							virtual void doGetJoke(::grpc::ClientContext* context, const ::wxhomework::JokeRequest* request, ::wxhomework::JokeResponse* response, std::function<void(::grpc::Status)>) = 0;
							virtual void doGetJoke(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::wxhomework::JokeResponse* response, std::function<void(::grpc::Status)>) = 0;
							virtual void doGetJoke(::grpc::ClientContext* context, const ::wxhomework::JokeRequest* request, ::wxhomework::JokeResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
							virtual void doGetJoke(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::wxhomework::JokeResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
					};
					virtual class experimental_async_interface* experimental_async() {
							return nullptr;
					}
				private:
					virtual ::grpc::ClientAsyncResponseReaderInterface< ::wxhomework::JokeResponse>* AsyncdoGetJokeRaw(::grpc::ClientContext* context, const ::wxhomework::JokeRequest& request, ::grpc::CompletionQueue* cq) = 0;
					virtual ::grpc::ClientAsyncResponseReaderInterface< ::wxhomework::JokeResponse>* PrepareAsyncdoGetJokeRaw(::grpc::ClientContext* context, const ::wxhomework::JokeRequest& request, ::grpc::CompletionQueue* cq) = 0;
			};
			class Stub final : public StubInterface {
				public:
					Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);
					::grpc::Status doGetJoke(::grpc::ClientContext* context, const ::wxhomework::JokeRequest& request, ::wxhomework::JokeResponse* response) override;
					std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::wxhomework::JokeResponse>> AsyncdoGetJoke(::grpc::ClientContext* context, const ::wxhomework::JokeRequest& request, ::grpc::CompletionQueue* cq) {
						return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::wxhomework::JokeResponse>>(AsyncdoGetJokeRaw(context, request, cq));
					}
					std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::wxhomework::JokeResponse>> PrepareAsyncdoGetJoke(::grpc::ClientContext* context, const ::wxhomework::JokeRequest& request, ::grpc::CompletionQueue* cq) {
						return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::wxhomework::JokeResponse>>(PrepareAsyncdoGetJokeRaw(context, request, cq));
					}
					class experimental_async final :
						public StubInterface::experimental_async_interface {
						public:
							void doGetJoke(::grpc::ClientContext* context, const ::wxhomework::JokeRequest* request, ::wxhomework::JokeResponse* response, std::function<void(::grpc::Status)>) override;
							void doGetJoke(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::wxhomework::JokeResponse* response, std::function<void(::grpc::Status)>) override;
							void doGetJoke(::grpc::ClientContext* context, const ::wxhomework::JokeRequest* request, ::wxhomework::JokeResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
							void doGetJoke(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::wxhomework::JokeResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
						private:
							friend class Stub;
							explicit experimental_async(Stub* stub): stub_(stub) { }
							Stub* stub() {
								return stub_;
							}
							Stub* stub_;
					};
					class experimental_async_interface* experimental_async() override {
							return &async_stub_;
					}

				private:
					std::shared_ptr< ::grpc::ChannelInterface> channel_;
					class experimental_async async_stub_ {
							this
					};
					::grpc::ClientAsyncResponseReader< ::wxhomework::JokeResponse>* AsyncdoGetJokeRaw(::grpc::ClientContext* context, const ::wxhomework::JokeRequest& request, ::grpc::CompletionQueue* cq) override;
					::grpc::ClientAsyncResponseReader< ::wxhomework::JokeResponse>* PrepareAsyncdoGetJokeRaw(::grpc::ClientContext* context, const ::wxhomework::JokeRequest& request, ::grpc::CompletionQueue* cq) override;
					const ::grpc::internal::RpcMethod rpcmethod_doGetJoke_;
			};
			static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

			class Service : public ::grpc::Service {
				public:
					Service();
					virtual ~Service();
					virtual ::grpc::Status doGetJoke(::grpc::ServerContext* context, const ::wxhomework::JokeRequest* request, ::wxhomework::JokeResponse* response);
			};
			template <class BaseClass>
			class WithAsyncMethod_doGetJoke : public BaseClass {
				private:
					void BaseClassMustBeDerivedFromService(const Service *service) {}
				public:
					WithAsyncMethod_doGetJoke() {
						::grpc::Service::MarkMethodAsync(0);
					}
					~WithAsyncMethod_doGetJoke() override {
						BaseClassMustBeDerivedFromService(this);
					}
					// disable synchronous version of this method
					::grpc::Status doGetJoke(::grpc::ServerContext* context, const ::wxhomework::JokeRequest* request, ::wxhomework::JokeResponse* response) override {
						abort();
						return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
					}
					void RequestdoGetJoke(::grpc::ServerContext* context, ::wxhomework::JokeRequest* request, ::grpc::ServerAsyncResponseWriter< ::wxhomework::JokeResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
						::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
					}
			};
			typedef WithAsyncMethod_doGetJoke<Service > AsyncService;
			template <class BaseClass>
			class ExperimentalWithCallbackMethod_doGetJoke : public BaseClass {
				private:
					void BaseClassMustBeDerivedFromService(const Service *service) {}
				public:
					ExperimentalWithCallbackMethod_doGetJoke() {
						::grpc::Service::experimental().MarkMethodCallback(0,
						        new ::grpc::internal::CallbackUnaryHandler< ::wxhomework::JokeRequest, ::wxhomework::JokeResponse>(
						            [this](::grpc::ServerContext* context,
						                   const ::wxhomework::JokeRequest* request,
						                   ::wxhomework::JokeResponse* response,
						::grpc::experimental::ServerCallbackRpcController* controller) {
							return this->doGetJoke(context, request, response, controller);
						}));
					}
					void SetMessageAllocatorFor_doGetJoke(
					    ::grpc::experimental::MessageAllocator< ::wxhomework::JokeRequest, ::wxhomework::JokeResponse>* allocator) {
						static_cast<::grpc::internal::CallbackUnaryHandler< ::wxhomework::JokeRequest, ::wxhomework::JokeResponse>*>(
						    ::grpc::Service::experimental().GetHandler(0))
						->SetMessageAllocator(allocator);
					}
					~ExperimentalWithCallbackMethod_doGetJoke() override {
						BaseClassMustBeDerivedFromService(this);
					}
					// disable synchronous version of this method
					::grpc::Status doGetJoke(::grpc::ServerContext* context, const ::wxhomework::JokeRequest* request, ::wxhomework::JokeResponse* response) override {
						abort();
						return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
					}
					virtual void doGetJoke(::grpc::ServerContext* context, const ::wxhomework::JokeRequest* request, ::wxhomework::JokeResponse* response, ::grpc::experimental::ServerCallbackRpcController* controller) {
						controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, ""));
					}
			};
			typedef ExperimentalWithCallbackMethod_doGetJoke<Service > ExperimentalCallbackService;
			template <class BaseClass>
			class WithGenericMethod_doGetJoke : public BaseClass {
				private:
					void BaseClassMustBeDerivedFromService(const Service *service) {}
				public:
					WithGenericMethod_doGetJoke() {
						::grpc::Service::MarkMethodGeneric(0);
					}
					~WithGenericMethod_doGetJoke() override {
						BaseClassMustBeDerivedFromService(this);
					}
					// disable synchronous version of this method
					::grpc::Status doGetJoke(::grpc::ServerContext* context, const ::wxhomework::JokeRequest* request, ::wxhomework::JokeResponse* response) override {
						abort();
						return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
					}
			};
			template <class BaseClass>
			class WithRawMethod_doGetJoke : public BaseClass {
				private:
					void BaseClassMustBeDerivedFromService(const Service *service) {}
				public:
					WithRawMethod_doGetJoke() {
						::grpc::Service::MarkMethodRaw(0);
					}
					~WithRawMethod_doGetJoke() override {
						BaseClassMustBeDerivedFromService(this);
					}
					// disable synchronous version of this method
					::grpc::Status doGetJoke(::grpc::ServerContext* context, const ::wxhomework::JokeRequest* request, ::wxhomework::JokeResponse* response) override {
						abort();
						return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
					}
					void RequestdoGetJoke(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
						::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
					}
			};
			template <class BaseClass>
			class ExperimentalWithRawCallbackMethod_doGetJoke : public BaseClass {
				private:
					void BaseClassMustBeDerivedFromService(const Service *service) {}
				public:
					ExperimentalWithRawCallbackMethod_doGetJoke() {
						::grpc::Service::experimental().MarkMethodRawCallback(0,
						        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
						            [this](::grpc::ServerContext* context,
						                   const ::grpc::ByteBuffer* request,
						                   ::grpc::ByteBuffer* response,
						::grpc::experimental::ServerCallbackRpcController* controller) {
							this->doGetJoke(context, request, response, controller);
						}));
					}
					~ExperimentalWithRawCallbackMethod_doGetJoke() override {
						BaseClassMustBeDerivedFromService(this);
					}
					// disable synchronous version of this method
					::grpc::Status doGetJoke(::grpc::ServerContext* context, const ::wxhomework::JokeRequest* request, ::wxhomework::JokeResponse* response) override {
						abort();
						return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
					}
					virtual void doGetJoke(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) {
						controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, ""));
					}
			};
			template <class BaseClass>
			class WithStreamedUnaryMethod_doGetJoke : public BaseClass {
				private:
					void BaseClassMustBeDerivedFromService(const Service *service) {}
				public:
					WithStreamedUnaryMethod_doGetJoke() {
						::grpc::Service::MarkMethodStreamed(0,
						                                    new ::grpc::internal::StreamedUnaryHandler< ::wxhomework::JokeRequest, ::wxhomework::JokeResponse>(std::bind(&WithStreamedUnaryMethod_doGetJoke<BaseClass>::StreameddoGetJoke, this, std::placeholders::_1, std::placeholders::_2)));
					}
					~WithStreamedUnaryMethod_doGetJoke() override {
						BaseClassMustBeDerivedFromService(this);
					}
					// disable regular version of this method
					::grpc::Status doGetJoke(::grpc::ServerContext* context, const ::wxhomework::JokeRequest* request, ::wxhomework::JokeResponse* response) override {
						abort();
						return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
					}
					// replace default version of method with streamed unary
					virtual ::grpc::Status StreameddoGetJoke(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::wxhomework::JokeRequest,::wxhomework::JokeResponse>* server_unary_streamer) = 0;
			};
			typedef WithStreamedUnaryMethod_doGetJoke<Service > StreamedUnaryService;
			typedef Service SplitStreamedService;
			typedef WithStreamedUnaryMethod_doGetJoke<Service > StreamedService;
	};

// 消息传递Service
	class MessageService final {
		public:
			static constexpr char const* service_full_name() {
				return "wxhomework.MessageService";
			}
			class StubInterface {
				public:
					virtual ~StubInterface() {}
					virtual ::grpc::Status doMessageBroadcast(::grpc::ClientContext* context, const ::wxhomework::SendMessageRequest& request, ::wxhomework::SendMessageResponse* response) = 0;
					std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::wxhomework::SendMessageResponse>> AsyncdoMessageBroadcast(::grpc::ClientContext* context, const ::wxhomework::SendMessageRequest& request, ::grpc::CompletionQueue* cq) {
						return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::wxhomework::SendMessageResponse>>(AsyncdoMessageBroadcastRaw(context, request, cq));
					}
					std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::wxhomework::SendMessageResponse>> PrepareAsyncdoMessageBroadcast(::grpc::ClientContext* context, const ::wxhomework::SendMessageRequest& request, ::grpc::CompletionQueue* cq) {
						return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::wxhomework::SendMessageResponse>>(PrepareAsyncdoMessageBroadcastRaw(context, request, cq));
					}
					virtual ::grpc::Status doMessageReceiver(::grpc::ClientContext* context, const ::wxhomework::ReceiveMessageRequest& request, ::wxhomework::ReceiveMessageResponse* response) = 0;
					std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::wxhomework::ReceiveMessageResponse>> AsyncdoMessageReceiver(::grpc::ClientContext* context, const ::wxhomework::ReceiveMessageRequest& request, ::grpc::CompletionQueue* cq) {
						return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::wxhomework::ReceiveMessageResponse>>(AsyncdoMessageReceiverRaw(context, request, cq));
					}
					std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::wxhomework::ReceiveMessageResponse>> PrepareAsyncdoMessageReceiver(::grpc::ClientContext* context, const ::wxhomework::ReceiveMessageRequest& request, ::grpc::CompletionQueue* cq) {
						return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::wxhomework::ReceiveMessageResponse>>(PrepareAsyncdoMessageReceiverRaw(context, request, cq));
					}
					virtual ::grpc::Status doPraise(::grpc::ClientContext* context, const ::wxhomework::PraiseRequest& request, ::wxhomework::PraiseResponse* response) = 0;
					std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::wxhomework::PraiseResponse>> AsyncdoPraise(::grpc::ClientContext* context, const ::wxhomework::PraiseRequest& request, ::grpc::CompletionQueue* cq) {
						return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::wxhomework::PraiseResponse>>(AsyncdoPraiseRaw(context, request, cq));
					}
					std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::wxhomework::PraiseResponse>> PrepareAsyncdoPraise(::grpc::ClientContext* context, const ::wxhomework::PraiseRequest& request, ::grpc::CompletionQueue* cq) {
						return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::wxhomework::PraiseResponse>>(PrepareAsyncdoPraiseRaw(context, request, cq));
					}
					class experimental_async_interface {
						public:
							virtual ~experimental_async_interface() {}
							virtual void doMessageBroadcast(::grpc::ClientContext* context, const ::wxhomework::SendMessageRequest* request, ::wxhomework::SendMessageResponse* response, std::function<void(::grpc::Status)>) = 0;
							virtual void doMessageBroadcast(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::wxhomework::SendMessageResponse* response, std::function<void(::grpc::Status)>) = 0;
							virtual void doMessageBroadcast(::grpc::ClientContext* context, const ::wxhomework::SendMessageRequest* request, ::wxhomework::SendMessageResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
							virtual void doMessageBroadcast(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::wxhomework::SendMessageResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
							virtual void doMessageReceiver(::grpc::ClientContext* context, const ::wxhomework::ReceiveMessageRequest* request, ::wxhomework::ReceiveMessageResponse* response, std::function<void(::grpc::Status)>) = 0;
							virtual void doMessageReceiver(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::wxhomework::ReceiveMessageResponse* response, std::function<void(::grpc::Status)>) = 0;
							virtual void doMessageReceiver(::grpc::ClientContext* context, const ::wxhomework::ReceiveMessageRequest* request, ::wxhomework::ReceiveMessageResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
							virtual void doMessageReceiver(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::wxhomework::ReceiveMessageResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
							virtual void doPraise(::grpc::ClientContext* context, const ::wxhomework::PraiseRequest* request, ::wxhomework::PraiseResponse* response, std::function<void(::grpc::Status)>) = 0;
							virtual void doPraise(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::wxhomework::PraiseResponse* response, std::function<void(::grpc::Status)>) = 0;
							virtual void doPraise(::grpc::ClientContext* context, const ::wxhomework::PraiseRequest* request, ::wxhomework::PraiseResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
							virtual void doPraise(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::wxhomework::PraiseResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
					};
					virtual class experimental_async_interface* experimental_async() {
							return nullptr;
					}
				private:
					virtual ::grpc::ClientAsyncResponseReaderInterface< ::wxhomework::SendMessageResponse>* AsyncdoMessageBroadcastRaw(::grpc::ClientContext* context, const ::wxhomework::SendMessageRequest& request, ::grpc::CompletionQueue* cq) = 0;
					virtual ::grpc::ClientAsyncResponseReaderInterface< ::wxhomework::SendMessageResponse>* PrepareAsyncdoMessageBroadcastRaw(::grpc::ClientContext* context, const ::wxhomework::SendMessageRequest& request, ::grpc::CompletionQueue* cq) = 0;
					virtual ::grpc::ClientAsyncResponseReaderInterface< ::wxhomework::ReceiveMessageResponse>* AsyncdoMessageReceiverRaw(::grpc::ClientContext* context, const ::wxhomework::ReceiveMessageRequest& request, ::grpc::CompletionQueue* cq) = 0;
					virtual ::grpc::ClientAsyncResponseReaderInterface< ::wxhomework::ReceiveMessageResponse>* PrepareAsyncdoMessageReceiverRaw(::grpc::ClientContext* context, const ::wxhomework::ReceiveMessageRequest& request, ::grpc::CompletionQueue* cq) = 0;
					virtual ::grpc::ClientAsyncResponseReaderInterface< ::wxhomework::PraiseResponse>* AsyncdoPraiseRaw(::grpc::ClientContext* context, const ::wxhomework::PraiseRequest& request, ::grpc::CompletionQueue* cq) = 0;
					virtual ::grpc::ClientAsyncResponseReaderInterface< ::wxhomework::PraiseResponse>* PrepareAsyncdoPraiseRaw(::grpc::ClientContext* context, const ::wxhomework::PraiseRequest& request, ::grpc::CompletionQueue* cq) = 0;
			};
			class Stub final : public StubInterface {
				public:
					Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);
					::grpc::Status doMessageBroadcast(::grpc::ClientContext* context, const ::wxhomework::SendMessageRequest& request, ::wxhomework::SendMessageResponse* response) override;
					std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::wxhomework::SendMessageResponse>> AsyncdoMessageBroadcast(::grpc::ClientContext* context, const ::wxhomework::SendMessageRequest& request, ::grpc::CompletionQueue* cq) {
						return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::wxhomework::SendMessageResponse>>(AsyncdoMessageBroadcastRaw(context, request, cq));
					}
					std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::wxhomework::SendMessageResponse>> PrepareAsyncdoMessageBroadcast(::grpc::ClientContext* context, const ::wxhomework::SendMessageRequest& request, ::grpc::CompletionQueue* cq) {
						return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::wxhomework::SendMessageResponse>>(PrepareAsyncdoMessageBroadcastRaw(context, request, cq));
					}
					::grpc::Status doMessageReceiver(::grpc::ClientContext* context, const ::wxhomework::ReceiveMessageRequest& request, ::wxhomework::ReceiveMessageResponse* response) override;
					std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::wxhomework::ReceiveMessageResponse>> AsyncdoMessageReceiver(::grpc::ClientContext* context, const ::wxhomework::ReceiveMessageRequest& request, ::grpc::CompletionQueue* cq) {
						return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::wxhomework::ReceiveMessageResponse>>(AsyncdoMessageReceiverRaw(context, request, cq));
					}
					std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::wxhomework::ReceiveMessageResponse>> PrepareAsyncdoMessageReceiver(::grpc::ClientContext* context, const ::wxhomework::ReceiveMessageRequest& request, ::grpc::CompletionQueue* cq) {
						return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::wxhomework::ReceiveMessageResponse>>(PrepareAsyncdoMessageReceiverRaw(context, request, cq));
					}
					::grpc::Status doPraise(::grpc::ClientContext* context, const ::wxhomework::PraiseRequest& request, ::wxhomework::PraiseResponse* response) override;
					std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::wxhomework::PraiseResponse>> AsyncdoPraise(::grpc::ClientContext* context, const ::wxhomework::PraiseRequest& request, ::grpc::CompletionQueue* cq) {
						return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::wxhomework::PraiseResponse>>(AsyncdoPraiseRaw(context, request, cq));
					}
					std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::wxhomework::PraiseResponse>> PrepareAsyncdoPraise(::grpc::ClientContext* context, const ::wxhomework::PraiseRequest& request, ::grpc::CompletionQueue* cq) {
						return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::wxhomework::PraiseResponse>>(PrepareAsyncdoPraiseRaw(context, request, cq));
					}
					class experimental_async final :
						public StubInterface::experimental_async_interface {
						public:
							void doMessageBroadcast(::grpc::ClientContext* context, const ::wxhomework::SendMessageRequest* request, ::wxhomework::SendMessageResponse* response, std::function<void(::grpc::Status)>) override;
							void doMessageBroadcast(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::wxhomework::SendMessageResponse* response, std::function<void(::grpc::Status)>) override;
							void doMessageBroadcast(::grpc::ClientContext* context, const ::wxhomework::SendMessageRequest* request, ::wxhomework::SendMessageResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
							void doMessageBroadcast(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::wxhomework::SendMessageResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
							void doMessageReceiver(::grpc::ClientContext* context, const ::wxhomework::ReceiveMessageRequest* request, ::wxhomework::ReceiveMessageResponse* response, std::function<void(::grpc::Status)>) override;
							void doMessageReceiver(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::wxhomework::ReceiveMessageResponse* response, std::function<void(::grpc::Status)>) override;
							void doMessageReceiver(::grpc::ClientContext* context, const ::wxhomework::ReceiveMessageRequest* request, ::wxhomework::ReceiveMessageResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
							void doMessageReceiver(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::wxhomework::ReceiveMessageResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
							void doPraise(::grpc::ClientContext* context, const ::wxhomework::PraiseRequest* request, ::wxhomework::PraiseResponse* response, std::function<void(::grpc::Status)>) override;
							void doPraise(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::wxhomework::PraiseResponse* response, std::function<void(::grpc::Status)>) override;
							void doPraise(::grpc::ClientContext* context, const ::wxhomework::PraiseRequest* request, ::wxhomework::PraiseResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
							void doPraise(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::wxhomework::PraiseResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
						private:
							friend class Stub;
							explicit experimental_async(Stub* stub): stub_(stub) { }
							Stub* stub() {
								return stub_;
							}
							Stub* stub_;
					};
					class experimental_async_interface* experimental_async() override {
							return &async_stub_;
					}

				private:
					std::shared_ptr< ::grpc::ChannelInterface> channel_;
					class experimental_async async_stub_ {
							this
					};
					::grpc::ClientAsyncResponseReader< ::wxhomework::SendMessageResponse>* AsyncdoMessageBroadcastRaw(::grpc::ClientContext* context, const ::wxhomework::SendMessageRequest& request, ::grpc::CompletionQueue* cq) override;
					::grpc::ClientAsyncResponseReader< ::wxhomework::SendMessageResponse>* PrepareAsyncdoMessageBroadcastRaw(::grpc::ClientContext* context, const ::wxhomework::SendMessageRequest& request, ::grpc::CompletionQueue* cq) override;
					::grpc::ClientAsyncResponseReader< ::wxhomework::ReceiveMessageResponse>* AsyncdoMessageReceiverRaw(::grpc::ClientContext* context, const ::wxhomework::ReceiveMessageRequest& request, ::grpc::CompletionQueue* cq) override;
					::grpc::ClientAsyncResponseReader< ::wxhomework::ReceiveMessageResponse>* PrepareAsyncdoMessageReceiverRaw(::grpc::ClientContext* context, const ::wxhomework::ReceiveMessageRequest& request, ::grpc::CompletionQueue* cq) override;
					::grpc::ClientAsyncResponseReader< ::wxhomework::PraiseResponse>* AsyncdoPraiseRaw(::grpc::ClientContext* context, const ::wxhomework::PraiseRequest& request, ::grpc::CompletionQueue* cq) override;
					::grpc::ClientAsyncResponseReader< ::wxhomework::PraiseResponse>* PrepareAsyncdoPraiseRaw(::grpc::ClientContext* context, const ::wxhomework::PraiseRequest& request, ::grpc::CompletionQueue* cq) override;
					const ::grpc::internal::RpcMethod rpcmethod_doMessageBroadcast_;
					const ::grpc::internal::RpcMethod rpcmethod_doMessageReceiver_;
					const ::grpc::internal::RpcMethod rpcmethod_doPraise_;
			};
			static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

			class Service : public ::grpc::Service {
				public:
					Service();
					virtual ~Service();
					virtual ::grpc::Status doMessageBroadcast(::grpc::ServerContext* context, const ::wxhomework::SendMessageRequest* request, ::wxhomework::SendMessageResponse* response);
					virtual ::grpc::Status doMessageReceiver(::grpc::ServerContext* context, const ::wxhomework::ReceiveMessageRequest* request, ::wxhomework::ReceiveMessageResponse* response);
					virtual ::grpc::Status doPraise(::grpc::ServerContext* context, const ::wxhomework::PraiseRequest* request, ::wxhomework::PraiseResponse* response);
			};
			template <class BaseClass>
			class WithAsyncMethod_doMessageBroadcast : public BaseClass {
				private:
					void BaseClassMustBeDerivedFromService(const Service *service) {}
				public:
					WithAsyncMethod_doMessageBroadcast() {
						::grpc::Service::MarkMethodAsync(0);
					}
					~WithAsyncMethod_doMessageBroadcast() override {
						BaseClassMustBeDerivedFromService(this);
					}
					// disable synchronous version of this method
					::grpc::Status doMessageBroadcast(::grpc::ServerContext* context, const ::wxhomework::SendMessageRequest* request, ::wxhomework::SendMessageResponse* response) override {
						abort();
						return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
					}
					void RequestdoMessageBroadcast(::grpc::ServerContext* context, ::wxhomework::SendMessageRequest* request, ::grpc::ServerAsyncResponseWriter< ::wxhomework::SendMessageResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
						::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
					}
			};
			template <class BaseClass>
			class WithAsyncMethod_doMessageReceiver : public BaseClass {
				private:
					void BaseClassMustBeDerivedFromService(const Service *service) {}
				public:
					WithAsyncMethod_doMessageReceiver() {
						::grpc::Service::MarkMethodAsync(1);
					}
					~WithAsyncMethod_doMessageReceiver() override {
						BaseClassMustBeDerivedFromService(this);
					}
					// disable synchronous version of this method
					::grpc::Status doMessageReceiver(::grpc::ServerContext* context, const ::wxhomework::ReceiveMessageRequest* request, ::wxhomework::ReceiveMessageResponse* response) override {
						abort();
						return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
					}
					void RequestdoMessageReceiver(::grpc::ServerContext* context, ::wxhomework::ReceiveMessageRequest* request, ::grpc::ServerAsyncResponseWriter< ::wxhomework::ReceiveMessageResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
						::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
					}
			};
			template <class BaseClass>
			class WithAsyncMethod_doPraise : public BaseClass {
				private:
					void BaseClassMustBeDerivedFromService(const Service *service) {}
				public:
					WithAsyncMethod_doPraise() {
						::grpc::Service::MarkMethodAsync(2);
					}
					~WithAsyncMethod_doPraise() override {
						BaseClassMustBeDerivedFromService(this);
					}
					// disable synchronous version of this method
					::grpc::Status doPraise(::grpc::ServerContext* context, const ::wxhomework::PraiseRequest* request, ::wxhomework::PraiseResponse* response) override {
						abort();
						return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
					}
					void RequestdoPraise(::grpc::ServerContext* context, ::wxhomework::PraiseRequest* request, ::grpc::ServerAsyncResponseWriter< ::wxhomework::PraiseResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
						::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
					}
			};
			typedef WithAsyncMethod_doMessageBroadcast<WithAsyncMethod_doMessageReceiver<WithAsyncMethod_doPraise<Service > > > AsyncService;
			template <class BaseClass>
			class ExperimentalWithCallbackMethod_doMessageBroadcast : public BaseClass {
				private:
					void BaseClassMustBeDerivedFromService(const Service *service) {}
				public:
					ExperimentalWithCallbackMethod_doMessageBroadcast() {
						::grpc::Service::experimental().MarkMethodCallback(0,
						        new ::grpc::internal::CallbackUnaryHandler< ::wxhomework::SendMessageRequest, ::wxhomework::SendMessageResponse>(
						            [this](::grpc::ServerContext* context,
						                   const ::wxhomework::SendMessageRequest* request,
						                   ::wxhomework::SendMessageResponse* response,
						::grpc::experimental::ServerCallbackRpcController* controller) {
							return this->doMessageBroadcast(context, request, response, controller);
						}));
					}
					void SetMessageAllocatorFor_doMessageBroadcast(
					    ::grpc::experimental::MessageAllocator< ::wxhomework::SendMessageRequest, ::wxhomework::SendMessageResponse>* allocator) {
						static_cast<::grpc::internal::CallbackUnaryHandler< ::wxhomework::SendMessageRequest, ::wxhomework::SendMessageResponse>*>(
						    ::grpc::Service::experimental().GetHandler(0))
						->SetMessageAllocator(allocator);
					}
					~ExperimentalWithCallbackMethod_doMessageBroadcast() override {
						BaseClassMustBeDerivedFromService(this);
					}
					// disable synchronous version of this method
					::grpc::Status doMessageBroadcast(::grpc::ServerContext* context, const ::wxhomework::SendMessageRequest* request, ::wxhomework::SendMessageResponse* response) override {
						abort();
						return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
					}
					virtual void doMessageBroadcast(::grpc::ServerContext* context, const ::wxhomework::SendMessageRequest* request, ::wxhomework::SendMessageResponse* response, ::grpc::experimental::ServerCallbackRpcController* controller) {
						controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, ""));
					}
			};
			template <class BaseClass>
			class ExperimentalWithCallbackMethod_doMessageReceiver : public BaseClass {
				private:
					void BaseClassMustBeDerivedFromService(const Service *service) {}
				public:
					ExperimentalWithCallbackMethod_doMessageReceiver() {
						::grpc::Service::experimental().MarkMethodCallback(1,
						        new ::grpc::internal::CallbackUnaryHandler< ::wxhomework::ReceiveMessageRequest, ::wxhomework::ReceiveMessageResponse>(
						            [this](::grpc::ServerContext* context,
						                   const ::wxhomework::ReceiveMessageRequest* request,
						                   ::wxhomework::ReceiveMessageResponse* response,
						::grpc::experimental::ServerCallbackRpcController* controller) {
							return this->doMessageReceiver(context, request, response, controller);
						}));
					}
					void SetMessageAllocatorFor_doMessageReceiver(
					    ::grpc::experimental::MessageAllocator< ::wxhomework::ReceiveMessageRequest, ::wxhomework::ReceiveMessageResponse>* allocator) {
						static_cast<::grpc::internal::CallbackUnaryHandler< ::wxhomework::ReceiveMessageRequest, ::wxhomework::ReceiveMessageResponse>*>(
						    ::grpc::Service::experimental().GetHandler(1))
						->SetMessageAllocator(allocator);
					}
					~ExperimentalWithCallbackMethod_doMessageReceiver() override {
						BaseClassMustBeDerivedFromService(this);
					}
					// disable synchronous version of this method
					::grpc::Status doMessageReceiver(::grpc::ServerContext* context, const ::wxhomework::ReceiveMessageRequest* request, ::wxhomework::ReceiveMessageResponse* response) override {
						abort();
						return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
					}
					virtual void doMessageReceiver(::grpc::ServerContext* context, const ::wxhomework::ReceiveMessageRequest* request, ::wxhomework::ReceiveMessageResponse* response, ::grpc::experimental::ServerCallbackRpcController* controller) {
						controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, ""));
					}
			};
			template <class BaseClass>
			class ExperimentalWithCallbackMethod_doPraise : public BaseClass {
				private:
					void BaseClassMustBeDerivedFromService(const Service *service) {}
				public:
					ExperimentalWithCallbackMethod_doPraise() {
						::grpc::Service::experimental().MarkMethodCallback(2,
						        new ::grpc::internal::CallbackUnaryHandler< ::wxhomework::PraiseRequest, ::wxhomework::PraiseResponse>(
						            [this](::grpc::ServerContext* context,
						                   const ::wxhomework::PraiseRequest* request,
						                   ::wxhomework::PraiseResponse* response,
						::grpc::experimental::ServerCallbackRpcController* controller) {
							return this->doPraise(context, request, response, controller);
						}));
					}
					void SetMessageAllocatorFor_doPraise(
					    ::grpc::experimental::MessageAllocator< ::wxhomework::PraiseRequest, ::wxhomework::PraiseResponse>* allocator) {
						static_cast<::grpc::internal::CallbackUnaryHandler< ::wxhomework::PraiseRequest, ::wxhomework::PraiseResponse>*>(
						    ::grpc::Service::experimental().GetHandler(2))
						->SetMessageAllocator(allocator);
					}
					~ExperimentalWithCallbackMethod_doPraise() override {
						BaseClassMustBeDerivedFromService(this);
					}
					// disable synchronous version of this method
					::grpc::Status doPraise(::grpc::ServerContext* context, const ::wxhomework::PraiseRequest* request, ::wxhomework::PraiseResponse* response) override {
						abort();
						return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
					}
					virtual void doPraise(::grpc::ServerContext* context, const ::wxhomework::PraiseRequest* request, ::wxhomework::PraiseResponse* response, ::grpc::experimental::ServerCallbackRpcController* controller) {
						controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, ""));
					}
			};
			typedef ExperimentalWithCallbackMethod_doMessageBroadcast<ExperimentalWithCallbackMethod_doMessageReceiver<ExperimentalWithCallbackMethod_doPraise<Service > > > ExperimentalCallbackService;
			template <class BaseClass>
			class WithGenericMethod_doMessageBroadcast : public BaseClass {
				private:
					void BaseClassMustBeDerivedFromService(const Service *service) {}
				public:
					WithGenericMethod_doMessageBroadcast() {
						::grpc::Service::MarkMethodGeneric(0);
					}
					~WithGenericMethod_doMessageBroadcast() override {
						BaseClassMustBeDerivedFromService(this);
					}
					// disable synchronous version of this method
					::grpc::Status doMessageBroadcast(::grpc::ServerContext* context, const ::wxhomework::SendMessageRequest* request, ::wxhomework::SendMessageResponse* response) override {
						abort();
						return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
					}
			};
			template <class BaseClass>
			class WithGenericMethod_doMessageReceiver : public BaseClass {
				private:
					void BaseClassMustBeDerivedFromService(const Service *service) {}
				public:
					WithGenericMethod_doMessageReceiver() {
						::grpc::Service::MarkMethodGeneric(1);
					}
					~WithGenericMethod_doMessageReceiver() override {
						BaseClassMustBeDerivedFromService(this);
					}
					// disable synchronous version of this method
					::grpc::Status doMessageReceiver(::grpc::ServerContext* context, const ::wxhomework::ReceiveMessageRequest* request, ::wxhomework::ReceiveMessageResponse* response) override {
						abort();
						return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
					}
			};
			template <class BaseClass>
			class WithGenericMethod_doPraise : public BaseClass {
				private:
					void BaseClassMustBeDerivedFromService(const Service *service) {}
				public:
					WithGenericMethod_doPraise() {
						::grpc::Service::MarkMethodGeneric(2);
					}
					~WithGenericMethod_doPraise() override {
						BaseClassMustBeDerivedFromService(this);
					}
					// disable synchronous version of this method
					::grpc::Status doPraise(::grpc::ServerContext* context, const ::wxhomework::PraiseRequest* request, ::wxhomework::PraiseResponse* response) override {
						abort();
						return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
					}
			};
			template <class BaseClass>
			class WithRawMethod_doMessageBroadcast : public BaseClass {
				private:
					void BaseClassMustBeDerivedFromService(const Service *service) {}
				public:
					WithRawMethod_doMessageBroadcast() {
						::grpc::Service::MarkMethodRaw(0);
					}
					~WithRawMethod_doMessageBroadcast() override {
						BaseClassMustBeDerivedFromService(this);
					}
					// disable synchronous version of this method
					::grpc::Status doMessageBroadcast(::grpc::ServerContext* context, const ::wxhomework::SendMessageRequest* request, ::wxhomework::SendMessageResponse* response) override {
						abort();
						return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
					}
					void RequestdoMessageBroadcast(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
						::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
					}
			};
			template <class BaseClass>
			class WithRawMethod_doMessageReceiver : public BaseClass {
				private:
					void BaseClassMustBeDerivedFromService(const Service *service) {}
				public:
					WithRawMethod_doMessageReceiver() {
						::grpc::Service::MarkMethodRaw(1);
					}
					~WithRawMethod_doMessageReceiver() override {
						BaseClassMustBeDerivedFromService(this);
					}
					// disable synchronous version of this method
					::grpc::Status doMessageReceiver(::grpc::ServerContext* context, const ::wxhomework::ReceiveMessageRequest* request, ::wxhomework::ReceiveMessageResponse* response) override {
						abort();
						return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
					}
					void RequestdoMessageReceiver(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
						::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
					}
			};
			template <class BaseClass>
			class WithRawMethod_doPraise : public BaseClass {
				private:
					void BaseClassMustBeDerivedFromService(const Service *service) {}
				public:
					WithRawMethod_doPraise() {
						::grpc::Service::MarkMethodRaw(2);
					}
					~WithRawMethod_doPraise() override {
						BaseClassMustBeDerivedFromService(this);
					}
					// disable synchronous version of this method
					::grpc::Status doPraise(::grpc::ServerContext* context, const ::wxhomework::PraiseRequest* request, ::wxhomework::PraiseResponse* response) override {
						abort();
						return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
					}
					void RequestdoPraise(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
						::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
					}
			};
			template <class BaseClass>
			class ExperimentalWithRawCallbackMethod_doMessageBroadcast : public BaseClass {
				private:
					void BaseClassMustBeDerivedFromService(const Service *service) {}
				public:
					ExperimentalWithRawCallbackMethod_doMessageBroadcast() {
						::grpc::Service::experimental().MarkMethodRawCallback(0,
						        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
						            [this](::grpc::ServerContext* context,
						                   const ::grpc::ByteBuffer* request,
						                   ::grpc::ByteBuffer* response,
						::grpc::experimental::ServerCallbackRpcController* controller) {
							this->doMessageBroadcast(context, request, response, controller);
						}));
					}
					~ExperimentalWithRawCallbackMethod_doMessageBroadcast() override {
						BaseClassMustBeDerivedFromService(this);
					}
					// disable synchronous version of this method
					::grpc::Status doMessageBroadcast(::grpc::ServerContext* context, const ::wxhomework::SendMessageRequest* request, ::wxhomework::SendMessageResponse* response) override {
						abort();
						return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
					}
					virtual void doMessageBroadcast(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) {
						controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, ""));
					}
			};
			template <class BaseClass>
			class ExperimentalWithRawCallbackMethod_doMessageReceiver : public BaseClass {
				private:
					void BaseClassMustBeDerivedFromService(const Service *service) {}
				public:
					ExperimentalWithRawCallbackMethod_doMessageReceiver() {
						::grpc::Service::experimental().MarkMethodRawCallback(1,
						        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
						            [this](::grpc::ServerContext* context,
						                   const ::grpc::ByteBuffer* request,
						                   ::grpc::ByteBuffer* response,
						::grpc::experimental::ServerCallbackRpcController* controller) {
							this->doMessageReceiver(context, request, response, controller);
						}));
					}
					~ExperimentalWithRawCallbackMethod_doMessageReceiver() override {
						BaseClassMustBeDerivedFromService(this);
					}
					// disable synchronous version of this method
					::grpc::Status doMessageReceiver(::grpc::ServerContext* context, const ::wxhomework::ReceiveMessageRequest* request, ::wxhomework::ReceiveMessageResponse* response) override {
						abort();
						return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
					}
					virtual void doMessageReceiver(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) {
						controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, ""));
					}
			};
			template <class BaseClass>
			class ExperimentalWithRawCallbackMethod_doPraise : public BaseClass {
				private:
					void BaseClassMustBeDerivedFromService(const Service *service) {}
				public:
					ExperimentalWithRawCallbackMethod_doPraise() {
						::grpc::Service::experimental().MarkMethodRawCallback(2,
						        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
						            [this](::grpc::ServerContext* context,
						                   const ::grpc::ByteBuffer* request,
						                   ::grpc::ByteBuffer* response,
						::grpc::experimental::ServerCallbackRpcController* controller) {
							this->doPraise(context, request, response, controller);
						}));
					}
					~ExperimentalWithRawCallbackMethod_doPraise() override {
						BaseClassMustBeDerivedFromService(this);
					}
					// disable synchronous version of this method
					::grpc::Status doPraise(::grpc::ServerContext* context, const ::wxhomework::PraiseRequest* request, ::wxhomework::PraiseResponse* response) override {
						abort();
						return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
					}
					virtual void doPraise(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) {
						controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, ""));
					}
			};
			template <class BaseClass>
			class WithStreamedUnaryMethod_doMessageBroadcast : public BaseClass {
				private:
					void BaseClassMustBeDerivedFromService(const Service *service) {}
				public:
					WithStreamedUnaryMethod_doMessageBroadcast() {
						::grpc::Service::MarkMethodStreamed(0,
						                                    new ::grpc::internal::StreamedUnaryHandler< ::wxhomework::SendMessageRequest, ::wxhomework::SendMessageResponse>(std::bind(&WithStreamedUnaryMethod_doMessageBroadcast<BaseClass>::StreameddoMessageBroadcast, this, std::placeholders::_1, std::placeholders::_2)));
					}
					~WithStreamedUnaryMethod_doMessageBroadcast() override {
						BaseClassMustBeDerivedFromService(this);
					}
					// disable regular version of this method
					::grpc::Status doMessageBroadcast(::grpc::ServerContext* context, const ::wxhomework::SendMessageRequest* request, ::wxhomework::SendMessageResponse* response) override {
						abort();
						return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
					}
					// replace default version of method with streamed unary
					virtual ::grpc::Status StreameddoMessageBroadcast(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::wxhomework::SendMessageRequest,::wxhomework::SendMessageResponse>* server_unary_streamer) = 0;
			};
			template <class BaseClass>
			class WithStreamedUnaryMethod_doMessageReceiver : public BaseClass {
				private:
					void BaseClassMustBeDerivedFromService(const Service *service) {}
				public:
					WithStreamedUnaryMethod_doMessageReceiver() {
						::grpc::Service::MarkMethodStreamed(1,
						                                    new ::grpc::internal::StreamedUnaryHandler< ::wxhomework::ReceiveMessageRequest, ::wxhomework::ReceiveMessageResponse>(std::bind(&WithStreamedUnaryMethod_doMessageReceiver<BaseClass>::StreameddoMessageReceiver, this, std::placeholders::_1, std::placeholders::_2)));
					}
					~WithStreamedUnaryMethod_doMessageReceiver() override {
						BaseClassMustBeDerivedFromService(this);
					}
					// disable regular version of this method
					::grpc::Status doMessageReceiver(::grpc::ServerContext* context, const ::wxhomework::ReceiveMessageRequest* request, ::wxhomework::ReceiveMessageResponse* response) override {
						abort();
						return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
					}
					// replace default version of method with streamed unary
					virtual ::grpc::Status StreameddoMessageReceiver(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::wxhomework::ReceiveMessageRequest,::wxhomework::ReceiveMessageResponse>* server_unary_streamer) = 0;
			};
			template <class BaseClass>
			class WithStreamedUnaryMethod_doPraise : public BaseClass {
				private:
					void BaseClassMustBeDerivedFromService(const Service *service) {}
				public:
					WithStreamedUnaryMethod_doPraise() {
						::grpc::Service::MarkMethodStreamed(2,
						                                    new ::grpc::internal::StreamedUnaryHandler< ::wxhomework::PraiseRequest, ::wxhomework::PraiseResponse>(std::bind(&WithStreamedUnaryMethod_doPraise<BaseClass>::StreameddoPraise, this, std::placeholders::_1, std::placeholders::_2)));
					}
					~WithStreamedUnaryMethod_doPraise() override {
						BaseClassMustBeDerivedFromService(this);
					}
					// disable regular version of this method
					::grpc::Status doPraise(::grpc::ServerContext* context, const ::wxhomework::PraiseRequest* request, ::wxhomework::PraiseResponse* response) override {
						abort();
						return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
					}
					// replace default version of method with streamed unary
					virtual ::grpc::Status StreameddoPraise(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::wxhomework::PraiseRequest,::wxhomework::PraiseResponse>* server_unary_streamer) = 0;
			};
			typedef WithStreamedUnaryMethod_doMessageBroadcast<WithStreamedUnaryMethod_doMessageReceiver<WithStreamedUnaryMethod_doPraise<Service > > > StreamedUnaryService;
			typedef Service SplitStreamedService;
			typedef WithStreamedUnaryMethod_doMessageBroadcast<WithStreamedUnaryMethod_doMessageReceiver<WithStreamedUnaryMethod_doPraise<Service > > > StreamedService;
	};

// 资格认证Service
	class CcatService final {
		public:
			static constexpr char const* service_full_name() {
				return "wxhomework.CcatService";
			}
			class StubInterface {
				public:
					virtual ~StubInterface() {}
					virtual ::grpc::Status doDoctorCCAT(::grpc::ClientContext* context, const ::wxhomework::UserInfoRequest& request, ::wxhomework::CCATResponse* response) = 0;
					std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::wxhomework::CCATResponse>> AsyncdoDoctorCCAT(::grpc::ClientContext* context, const ::wxhomework::UserInfoRequest& request, ::grpc::CompletionQueue* cq) {
						return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::wxhomework::CCATResponse>>(AsyncdoDoctorCCATRaw(context, request, cq));
					}
					std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::wxhomework::CCATResponse>> PrepareAsyncdoDoctorCCAT(::grpc::ClientContext* context, const ::wxhomework::UserInfoRequest& request, ::grpc::CompletionQueue* cq) {
						return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::wxhomework::CCATResponse>>(PrepareAsyncdoDoctorCCATRaw(context, request, cq));
					}
					class experimental_async_interface {
						public:
							virtual ~experimental_async_interface() {}
							virtual void doDoctorCCAT(::grpc::ClientContext* context, const ::wxhomework::UserInfoRequest* request, ::wxhomework::CCATResponse* response, std::function<void(::grpc::Status)>) = 0;
							virtual void doDoctorCCAT(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::wxhomework::CCATResponse* response, std::function<void(::grpc::Status)>) = 0;
							virtual void doDoctorCCAT(::grpc::ClientContext* context, const ::wxhomework::UserInfoRequest* request, ::wxhomework::CCATResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
							virtual void doDoctorCCAT(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::wxhomework::CCATResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
					};
					virtual class experimental_async_interface* experimental_async() {
							return nullptr;
					}
				private:
					virtual ::grpc::ClientAsyncResponseReaderInterface< ::wxhomework::CCATResponse>* AsyncdoDoctorCCATRaw(::grpc::ClientContext* context, const ::wxhomework::UserInfoRequest& request, ::grpc::CompletionQueue* cq) = 0;
					virtual ::grpc::ClientAsyncResponseReaderInterface< ::wxhomework::CCATResponse>* PrepareAsyncdoDoctorCCATRaw(::grpc::ClientContext* context, const ::wxhomework::UserInfoRequest& request, ::grpc::CompletionQueue* cq) = 0;
			};
			class Stub final : public StubInterface {
				public:
					Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);
					::grpc::Status doDoctorCCAT(::grpc::ClientContext* context, const ::wxhomework::UserInfoRequest& request, ::wxhomework::CCATResponse* response) override;
					std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::wxhomework::CCATResponse>> AsyncdoDoctorCCAT(::grpc::ClientContext* context, const ::wxhomework::UserInfoRequest& request, ::grpc::CompletionQueue* cq) {
						return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::wxhomework::CCATResponse>>(AsyncdoDoctorCCATRaw(context, request, cq));
					}
					std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::wxhomework::CCATResponse>> PrepareAsyncdoDoctorCCAT(::grpc::ClientContext* context, const ::wxhomework::UserInfoRequest& request, ::grpc::CompletionQueue* cq) {
						return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::wxhomework::CCATResponse>>(PrepareAsyncdoDoctorCCATRaw(context, request, cq));
					}
					class experimental_async final :
						public StubInterface::experimental_async_interface {
						public:
							void doDoctorCCAT(::grpc::ClientContext* context, const ::wxhomework::UserInfoRequest* request, ::wxhomework::CCATResponse* response, std::function<void(::grpc::Status)>) override;
							void doDoctorCCAT(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::wxhomework::CCATResponse* response, std::function<void(::grpc::Status)>) override;
							void doDoctorCCAT(::grpc::ClientContext* context, const ::wxhomework::UserInfoRequest* request, ::wxhomework::CCATResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
							void doDoctorCCAT(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::wxhomework::CCATResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
						private:
							friend class Stub;
							explicit experimental_async(Stub* stub): stub_(stub) { }
							Stub* stub() {
								return stub_;
							}
							Stub* stub_;
					};
					class experimental_async_interface* experimental_async() override {
							return &async_stub_;
					}

				private:
					std::shared_ptr< ::grpc::ChannelInterface> channel_;
					class experimental_async async_stub_ {
							this
					};
					::grpc::ClientAsyncResponseReader< ::wxhomework::CCATResponse>* AsyncdoDoctorCCATRaw(::grpc::ClientContext* context, const ::wxhomework::UserInfoRequest& request, ::grpc::CompletionQueue* cq) override;
					::grpc::ClientAsyncResponseReader< ::wxhomework::CCATResponse>* PrepareAsyncdoDoctorCCATRaw(::grpc::ClientContext* context, const ::wxhomework::UserInfoRequest& request, ::grpc::CompletionQueue* cq) override;
					const ::grpc::internal::RpcMethod rpcmethod_doDoctorCCAT_;
			};
			static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

			class Service : public ::grpc::Service {
				public:
					Service();
					virtual ~Service();
					virtual ::grpc::Status doDoctorCCAT(::grpc::ServerContext* context, const ::wxhomework::UserInfoRequest* request, ::wxhomework::CCATResponse* response);
			};
			template <class BaseClass>
			class WithAsyncMethod_doDoctorCCAT : public BaseClass {
				private:
					void BaseClassMustBeDerivedFromService(const Service *service) {}
				public:
					WithAsyncMethod_doDoctorCCAT() {
						::grpc::Service::MarkMethodAsync(0);
					}
					~WithAsyncMethod_doDoctorCCAT() override {
						BaseClassMustBeDerivedFromService(this);
					}
					// disable synchronous version of this method
					::grpc::Status doDoctorCCAT(::grpc::ServerContext* context, const ::wxhomework::UserInfoRequest* request, ::wxhomework::CCATResponse* response) override {
						abort();
						return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
					}
					void RequestdoDoctorCCAT(::grpc::ServerContext* context, ::wxhomework::UserInfoRequest* request, ::grpc::ServerAsyncResponseWriter< ::wxhomework::CCATResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
						::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
					}
			};
			typedef WithAsyncMethod_doDoctorCCAT<Service > AsyncService;
			template <class BaseClass>
			class ExperimentalWithCallbackMethod_doDoctorCCAT : public BaseClass {
				private:
					void BaseClassMustBeDerivedFromService(const Service *service) {}
				public:
					ExperimentalWithCallbackMethod_doDoctorCCAT() {
						::grpc::Service::experimental().MarkMethodCallback(0,
						        new ::grpc::internal::CallbackUnaryHandler< ::wxhomework::UserInfoRequest, ::wxhomework::CCATResponse>(
						            [this](::grpc::ServerContext* context,
						                   const ::wxhomework::UserInfoRequest* request,
						                   ::wxhomework::CCATResponse* response,
						::grpc::experimental::ServerCallbackRpcController* controller) {
							return this->doDoctorCCAT(context, request, response, controller);
						}));
					}
					void SetMessageAllocatorFor_doDoctorCCAT(
					    ::grpc::experimental::MessageAllocator< ::wxhomework::UserInfoRequest, ::wxhomework::CCATResponse>* allocator) {
						static_cast<::grpc::internal::CallbackUnaryHandler< ::wxhomework::UserInfoRequest, ::wxhomework::CCATResponse>*>(
						    ::grpc::Service::experimental().GetHandler(0))
						->SetMessageAllocator(allocator);
					}
					~ExperimentalWithCallbackMethod_doDoctorCCAT() override {
						BaseClassMustBeDerivedFromService(this);
					}
					// disable synchronous version of this method
					::grpc::Status doDoctorCCAT(::grpc::ServerContext* context, const ::wxhomework::UserInfoRequest* request, ::wxhomework::CCATResponse* response) override {
						abort();
						return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
					}
					virtual void doDoctorCCAT(::grpc::ServerContext* context, const ::wxhomework::UserInfoRequest* request, ::wxhomework::CCATResponse* response, ::grpc::experimental::ServerCallbackRpcController* controller) {
						controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, ""));
					}
			};
			typedef ExperimentalWithCallbackMethod_doDoctorCCAT<Service > ExperimentalCallbackService;
			template <class BaseClass>
			class WithGenericMethod_doDoctorCCAT : public BaseClass {
				private:
					void BaseClassMustBeDerivedFromService(const Service *service) {}
				public:
					WithGenericMethod_doDoctorCCAT() {
						::grpc::Service::MarkMethodGeneric(0);
					}
					~WithGenericMethod_doDoctorCCAT() override {
						BaseClassMustBeDerivedFromService(this);
					}
					// disable synchronous version of this method
					::grpc::Status doDoctorCCAT(::grpc::ServerContext* context, const ::wxhomework::UserInfoRequest* request, ::wxhomework::CCATResponse* response) override {
						abort();
						return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
					}
			};
			template <class BaseClass>
			class WithRawMethod_doDoctorCCAT : public BaseClass {
				private:
					void BaseClassMustBeDerivedFromService(const Service *service) {}
				public:
					WithRawMethod_doDoctorCCAT() {
						::grpc::Service::MarkMethodRaw(0);
					}
					~WithRawMethod_doDoctorCCAT() override {
						BaseClassMustBeDerivedFromService(this);
					}
					// disable synchronous version of this method
					::grpc::Status doDoctorCCAT(::grpc::ServerContext* context, const ::wxhomework::UserInfoRequest* request, ::wxhomework::CCATResponse* response) override {
						abort();
						return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
					}
					void RequestdoDoctorCCAT(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
						::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
					}
			};
			template <class BaseClass>
			class ExperimentalWithRawCallbackMethod_doDoctorCCAT : public BaseClass {
				private:
					void BaseClassMustBeDerivedFromService(const Service *service) {}
				public:
					ExperimentalWithRawCallbackMethod_doDoctorCCAT() {
						::grpc::Service::experimental().MarkMethodRawCallback(0,
						        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
						            [this](::grpc::ServerContext* context,
						                   const ::grpc::ByteBuffer* request,
						                   ::grpc::ByteBuffer* response,
						::grpc::experimental::ServerCallbackRpcController* controller) {
							this->doDoctorCCAT(context, request, response, controller);
						}));
					}
					~ExperimentalWithRawCallbackMethod_doDoctorCCAT() override {
						BaseClassMustBeDerivedFromService(this);
					}
					// disable synchronous version of this method
					::grpc::Status doDoctorCCAT(::grpc::ServerContext* context, const ::wxhomework::UserInfoRequest* request, ::wxhomework::CCATResponse* response) override {
						abort();
						return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
					}
					virtual void doDoctorCCAT(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) {
						controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, ""));
					}
			};
			template <class BaseClass>
			class WithStreamedUnaryMethod_doDoctorCCAT : public BaseClass {
				private:
					void BaseClassMustBeDerivedFromService(const Service *service) {}
				public:
					WithStreamedUnaryMethod_doDoctorCCAT() {
						::grpc::Service::MarkMethodStreamed(0,
						                                    new ::grpc::internal::StreamedUnaryHandler< ::wxhomework::UserInfoRequest, ::wxhomework::CCATResponse>(std::bind(&WithStreamedUnaryMethod_doDoctorCCAT<BaseClass>::StreameddoDoctorCCAT, this, std::placeholders::_1, std::placeholders::_2)));
					}
					~WithStreamedUnaryMethod_doDoctorCCAT() override {
						BaseClassMustBeDerivedFromService(this);
					}
					// disable regular version of this method
					::grpc::Status doDoctorCCAT(::grpc::ServerContext* context, const ::wxhomework::UserInfoRequest* request, ::wxhomework::CCATResponse* response) override {
						abort();
						return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
					}
					// replace default version of method with streamed unary
					virtual ::grpc::Status StreameddoDoctorCCAT(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::wxhomework::UserInfoRequest,::wxhomework::CCATResponse>* server_unary_streamer) = 0;
			};
			typedef WithStreamedUnaryMethod_doDoctorCCAT<Service > StreamedUnaryService;
			typedef Service SplitStreamedService;
			typedef WithStreamedUnaryMethod_doDoctorCCAT<Service > StreamedService;
	};

// 登录模块Service
	class LoginService final {
		public:
			static constexpr char const* service_full_name() {
				return "wxhomework.LoginService";
			}
			class StubInterface {
				public:
					virtual ~StubInterface() {}
					virtual ::grpc::Status doLogin(::grpc::ClientContext* context, const ::wxhomework::UserInfoRequest& request, ::wxhomework::UserLoginResponse* response) = 0;
					std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::wxhomework::UserLoginResponse>> AsyncdoLogin(::grpc::ClientContext* context, const ::wxhomework::UserInfoRequest& request, ::grpc::CompletionQueue* cq) {
						return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::wxhomework::UserLoginResponse>>(AsyncdoLoginRaw(context, request, cq));
					}
					std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::wxhomework::UserLoginResponse>> PrepareAsyncdoLogin(::grpc::ClientContext* context, const ::wxhomework::UserInfoRequest& request, ::grpc::CompletionQueue* cq) {
						return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::wxhomework::UserLoginResponse>>(PrepareAsyncdoLoginRaw(context, request, cq));
					}
					virtual ::grpc::Status doLoginOut(::grpc::ClientContext* context, const ::wxhomework::UserInfoRequest& request, ::wxhomework::UserLoginResponse* response) = 0;
					std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::wxhomework::UserLoginResponse>> AsyncdoLoginOut(::grpc::ClientContext* context, const ::wxhomework::UserInfoRequest& request, ::grpc::CompletionQueue* cq) {
						return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::wxhomework::UserLoginResponse>>(AsyncdoLoginOutRaw(context, request, cq));
					}
					std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::wxhomework::UserLoginResponse>> PrepareAsyncdoLoginOut(::grpc::ClientContext* context, const ::wxhomework::UserInfoRequest& request, ::grpc::CompletionQueue* cq) {
						return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::wxhomework::UserLoginResponse>>(PrepareAsyncdoLoginOutRaw(context, request, cq));
					}
					virtual ::grpc::Status doRegister(::grpc::ClientContext* context, const ::wxhomework::UserInfoRequest& request, ::wxhomework::UserRegisterResponse* response) = 0;
					std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::wxhomework::UserRegisterResponse>> AsyncdoRegister(::grpc::ClientContext* context, const ::wxhomework::UserInfoRequest& request, ::grpc::CompletionQueue* cq) {
						return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::wxhomework::UserRegisterResponse>>(AsyncdoRegisterRaw(context, request, cq));
					}
					std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::wxhomework::UserRegisterResponse>> PrepareAsyncdoRegister(::grpc::ClientContext* context, const ::wxhomework::UserInfoRequest& request, ::grpc::CompletionQueue* cq) {
						return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::wxhomework::UserRegisterResponse>>(PrepareAsyncdoRegisterRaw(context, request, cq));
					}
					virtual ::grpc::Status doPasswordChange(::grpc::ClientContext* context, const ::wxhomework::UserInfoRequest& request, ::wxhomework::UserPasswordChangeResponse* response) = 0;
					std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::wxhomework::UserPasswordChangeResponse>> AsyncdoPasswordChange(::grpc::ClientContext* context, const ::wxhomework::UserInfoRequest& request, ::grpc::CompletionQueue* cq) {
						return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::wxhomework::UserPasswordChangeResponse>>(AsyncdoPasswordChangeRaw(context, request, cq));
					}
					std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::wxhomework::UserPasswordChangeResponse>> PrepareAsyncdoPasswordChange(::grpc::ClientContext* context, const ::wxhomework::UserInfoRequest& request, ::grpc::CompletionQueue* cq) {
						return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::wxhomework::UserPasswordChangeResponse>>(PrepareAsyncdoPasswordChangeRaw(context, request, cq));
					}
					class experimental_async_interface {
						public:
							virtual ~experimental_async_interface() {}
							virtual void doLogin(::grpc::ClientContext* context, const ::wxhomework::UserInfoRequest* request, ::wxhomework::UserLoginResponse* response, std::function<void(::grpc::Status)>) = 0;
							virtual void doLogin(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::wxhomework::UserLoginResponse* response, std::function<void(::grpc::Status)>) = 0;
							virtual void doLogin(::grpc::ClientContext* context, const ::wxhomework::UserInfoRequest* request, ::wxhomework::UserLoginResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
							virtual void doLogin(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::wxhomework::UserLoginResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
							virtual void doLoginOut(::grpc::ClientContext* context, const ::wxhomework::UserInfoRequest* request, ::wxhomework::UserLoginResponse* response, std::function<void(::grpc::Status)>) = 0;
							virtual void doLoginOut(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::wxhomework::UserLoginResponse* response, std::function<void(::grpc::Status)>) = 0;
							virtual void doLoginOut(::grpc::ClientContext* context, const ::wxhomework::UserInfoRequest* request, ::wxhomework::UserLoginResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
							virtual void doLoginOut(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::wxhomework::UserLoginResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
							virtual void doRegister(::grpc::ClientContext* context, const ::wxhomework::UserInfoRequest* request, ::wxhomework::UserRegisterResponse* response, std::function<void(::grpc::Status)>) = 0;
							virtual void doRegister(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::wxhomework::UserRegisterResponse* response, std::function<void(::grpc::Status)>) = 0;
							virtual void doRegister(::grpc::ClientContext* context, const ::wxhomework::UserInfoRequest* request, ::wxhomework::UserRegisterResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
							virtual void doRegister(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::wxhomework::UserRegisterResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
							virtual void doPasswordChange(::grpc::ClientContext* context, const ::wxhomework::UserInfoRequest* request, ::wxhomework::UserPasswordChangeResponse* response, std::function<void(::grpc::Status)>) = 0;
							virtual void doPasswordChange(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::wxhomework::UserPasswordChangeResponse* response, std::function<void(::grpc::Status)>) = 0;
							virtual void doPasswordChange(::grpc::ClientContext* context, const ::wxhomework::UserInfoRequest* request, ::wxhomework::UserPasswordChangeResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
							virtual void doPasswordChange(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::wxhomework::UserPasswordChangeResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
					};
					virtual class experimental_async_interface* experimental_async() {
							return nullptr;
					}
				private:
					virtual ::grpc::ClientAsyncResponseReaderInterface< ::wxhomework::UserLoginResponse>* AsyncdoLoginRaw(::grpc::ClientContext* context, const ::wxhomework::UserInfoRequest& request, ::grpc::CompletionQueue* cq) = 0;
					virtual ::grpc::ClientAsyncResponseReaderInterface< ::wxhomework::UserLoginResponse>* PrepareAsyncdoLoginRaw(::grpc::ClientContext* context, const ::wxhomework::UserInfoRequest& request, ::grpc::CompletionQueue* cq) = 0;
					virtual ::grpc::ClientAsyncResponseReaderInterface< ::wxhomework::UserLoginResponse>* AsyncdoLoginOutRaw(::grpc::ClientContext* context, const ::wxhomework::UserInfoRequest& request, ::grpc::CompletionQueue* cq) = 0;
					virtual ::grpc::ClientAsyncResponseReaderInterface< ::wxhomework::UserLoginResponse>* PrepareAsyncdoLoginOutRaw(::grpc::ClientContext* context, const ::wxhomework::UserInfoRequest& request, ::grpc::CompletionQueue* cq) = 0;
					virtual ::grpc::ClientAsyncResponseReaderInterface< ::wxhomework::UserRegisterResponse>* AsyncdoRegisterRaw(::grpc::ClientContext* context, const ::wxhomework::UserInfoRequest& request, ::grpc::CompletionQueue* cq) = 0;
					virtual ::grpc::ClientAsyncResponseReaderInterface< ::wxhomework::UserRegisterResponse>* PrepareAsyncdoRegisterRaw(::grpc::ClientContext* context, const ::wxhomework::UserInfoRequest& request, ::grpc::CompletionQueue* cq) = 0;
					virtual ::grpc::ClientAsyncResponseReaderInterface< ::wxhomework::UserPasswordChangeResponse>* AsyncdoPasswordChangeRaw(::grpc::ClientContext* context, const ::wxhomework::UserInfoRequest& request, ::grpc::CompletionQueue* cq) = 0;
					virtual ::grpc::ClientAsyncResponseReaderInterface< ::wxhomework::UserPasswordChangeResponse>* PrepareAsyncdoPasswordChangeRaw(::grpc::ClientContext* context, const ::wxhomework::UserInfoRequest& request, ::grpc::CompletionQueue* cq) = 0;
			};
			class Stub final : public StubInterface {
				public:
					Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);
					::grpc::Status doLogin(::grpc::ClientContext* context, const ::wxhomework::UserInfoRequest& request, ::wxhomework::UserLoginResponse* response) override;
					std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::wxhomework::UserLoginResponse>> AsyncdoLogin(::grpc::ClientContext* context, const ::wxhomework::UserInfoRequest& request, ::grpc::CompletionQueue* cq) {
						return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::wxhomework::UserLoginResponse>>(AsyncdoLoginRaw(context, request, cq));
					}
					std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::wxhomework::UserLoginResponse>> PrepareAsyncdoLogin(::grpc::ClientContext* context, const ::wxhomework::UserInfoRequest& request, ::grpc::CompletionQueue* cq) {
						return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::wxhomework::UserLoginResponse>>(PrepareAsyncdoLoginRaw(context, request, cq));
					}
					::grpc::Status doLoginOut(::grpc::ClientContext* context, const ::wxhomework::UserInfoRequest& request, ::wxhomework::UserLoginResponse* response) override;
					std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::wxhomework::UserLoginResponse>> AsyncdoLoginOut(::grpc::ClientContext* context, const ::wxhomework::UserInfoRequest& request, ::grpc::CompletionQueue* cq) {
						return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::wxhomework::UserLoginResponse>>(AsyncdoLoginOutRaw(context, request, cq));
					}
					std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::wxhomework::UserLoginResponse>> PrepareAsyncdoLoginOut(::grpc::ClientContext* context, const ::wxhomework::UserInfoRequest& request, ::grpc::CompletionQueue* cq) {
						return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::wxhomework::UserLoginResponse>>(PrepareAsyncdoLoginOutRaw(context, request, cq));
					}
					::grpc::Status doRegister(::grpc::ClientContext* context, const ::wxhomework::UserInfoRequest& request, ::wxhomework::UserRegisterResponse* response) override;
					std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::wxhomework::UserRegisterResponse>> AsyncdoRegister(::grpc::ClientContext* context, const ::wxhomework::UserInfoRequest& request, ::grpc::CompletionQueue* cq) {
						return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::wxhomework::UserRegisterResponse>>(AsyncdoRegisterRaw(context, request, cq));
					}
					std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::wxhomework::UserRegisterResponse>> PrepareAsyncdoRegister(::grpc::ClientContext* context, const ::wxhomework::UserInfoRequest& request, ::grpc::CompletionQueue* cq) {
						return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::wxhomework::UserRegisterResponse>>(PrepareAsyncdoRegisterRaw(context, request, cq));
					}
					::grpc::Status doPasswordChange(::grpc::ClientContext* context, const ::wxhomework::UserInfoRequest& request, ::wxhomework::UserPasswordChangeResponse* response) override;
					std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::wxhomework::UserPasswordChangeResponse>> AsyncdoPasswordChange(::grpc::ClientContext* context, const ::wxhomework::UserInfoRequest& request, ::grpc::CompletionQueue* cq) {
						return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::wxhomework::UserPasswordChangeResponse>>(AsyncdoPasswordChangeRaw(context, request, cq));
					}
					std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::wxhomework::UserPasswordChangeResponse>> PrepareAsyncdoPasswordChange(::grpc::ClientContext* context, const ::wxhomework::UserInfoRequest& request, ::grpc::CompletionQueue* cq) {
						return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::wxhomework::UserPasswordChangeResponse>>(PrepareAsyncdoPasswordChangeRaw(context, request, cq));
					}
					class experimental_async final :
						public StubInterface::experimental_async_interface {
						public:
							void doLogin(::grpc::ClientContext* context, const ::wxhomework::UserInfoRequest* request, ::wxhomework::UserLoginResponse* response, std::function<void(::grpc::Status)>) override;
							void doLogin(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::wxhomework::UserLoginResponse* response, std::function<void(::grpc::Status)>) override;
							void doLogin(::grpc::ClientContext* context, const ::wxhomework::UserInfoRequest* request, ::wxhomework::UserLoginResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
							void doLogin(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::wxhomework::UserLoginResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
							void doLoginOut(::grpc::ClientContext* context, const ::wxhomework::UserInfoRequest* request, ::wxhomework::UserLoginResponse* response, std::function<void(::grpc::Status)>) override;
							void doLoginOut(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::wxhomework::UserLoginResponse* response, std::function<void(::grpc::Status)>) override;
							void doLoginOut(::grpc::ClientContext* context, const ::wxhomework::UserInfoRequest* request, ::wxhomework::UserLoginResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
							void doLoginOut(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::wxhomework::UserLoginResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
							void doRegister(::grpc::ClientContext* context, const ::wxhomework::UserInfoRequest* request, ::wxhomework::UserRegisterResponse* response, std::function<void(::grpc::Status)>) override;
							void doRegister(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::wxhomework::UserRegisterResponse* response, std::function<void(::grpc::Status)>) override;
							void doRegister(::grpc::ClientContext* context, const ::wxhomework::UserInfoRequest* request, ::wxhomework::UserRegisterResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
							void doRegister(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::wxhomework::UserRegisterResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
							void doPasswordChange(::grpc::ClientContext* context, const ::wxhomework::UserInfoRequest* request, ::wxhomework::UserPasswordChangeResponse* response, std::function<void(::grpc::Status)>) override;
							void doPasswordChange(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::wxhomework::UserPasswordChangeResponse* response, std::function<void(::grpc::Status)>) override;
							void doPasswordChange(::grpc::ClientContext* context, const ::wxhomework::UserInfoRequest* request, ::wxhomework::UserPasswordChangeResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
							void doPasswordChange(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::wxhomework::UserPasswordChangeResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
						private:
							friend class Stub;
							explicit experimental_async(Stub* stub): stub_(stub) { }
							Stub* stub() {
								return stub_;
							}
							Stub* stub_;
					};
					class experimental_async_interface* experimental_async() override {
							return &async_stub_;
					}

				private:
					std::shared_ptr< ::grpc::ChannelInterface> channel_;
					class experimental_async async_stub_ {
							this
					};
					::grpc::ClientAsyncResponseReader< ::wxhomework::UserLoginResponse>* AsyncdoLoginRaw(::grpc::ClientContext* context, const ::wxhomework::UserInfoRequest& request, ::grpc::CompletionQueue* cq) override;
					::grpc::ClientAsyncResponseReader< ::wxhomework::UserLoginResponse>* PrepareAsyncdoLoginRaw(::grpc::ClientContext* context, const ::wxhomework::UserInfoRequest& request, ::grpc::CompletionQueue* cq) override;
					::grpc::ClientAsyncResponseReader< ::wxhomework::UserLoginResponse>* AsyncdoLoginOutRaw(::grpc::ClientContext* context, const ::wxhomework::UserInfoRequest& request, ::grpc::CompletionQueue* cq) override;
					::grpc::ClientAsyncResponseReader< ::wxhomework::UserLoginResponse>* PrepareAsyncdoLoginOutRaw(::grpc::ClientContext* context, const ::wxhomework::UserInfoRequest& request, ::grpc::CompletionQueue* cq) override;
					::grpc::ClientAsyncResponseReader< ::wxhomework::UserRegisterResponse>* AsyncdoRegisterRaw(::grpc::ClientContext* context, const ::wxhomework::UserInfoRequest& request, ::grpc::CompletionQueue* cq) override;
					::grpc::ClientAsyncResponseReader< ::wxhomework::UserRegisterResponse>* PrepareAsyncdoRegisterRaw(::grpc::ClientContext* context, const ::wxhomework::UserInfoRequest& request, ::grpc::CompletionQueue* cq) override;
					::grpc::ClientAsyncResponseReader< ::wxhomework::UserPasswordChangeResponse>* AsyncdoPasswordChangeRaw(::grpc::ClientContext* context, const ::wxhomework::UserInfoRequest& request, ::grpc::CompletionQueue* cq) override;
					::grpc::ClientAsyncResponseReader< ::wxhomework::UserPasswordChangeResponse>* PrepareAsyncdoPasswordChangeRaw(::grpc::ClientContext* context, const ::wxhomework::UserInfoRequest& request, ::grpc::CompletionQueue* cq) override;
					const ::grpc::internal::RpcMethod rpcmethod_doLogin_;
					const ::grpc::internal::RpcMethod rpcmethod_doLoginOut_;
					const ::grpc::internal::RpcMethod rpcmethod_doRegister_;
					const ::grpc::internal::RpcMethod rpcmethod_doPasswordChange_;
			};
			static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

			class Service : public ::grpc::Service {
				public:
					Service();
					virtual ~Service();
					virtual ::grpc::Status doLogin(::grpc::ServerContext* context, const ::wxhomework::UserInfoRequest* request, ::wxhomework::UserLoginResponse* response);
					virtual ::grpc::Status doLoginOut(::grpc::ServerContext* context, const ::wxhomework::UserInfoRequest* request, ::wxhomework::UserLoginResponse* response);
					virtual ::grpc::Status doRegister(::grpc::ServerContext* context, const ::wxhomework::UserInfoRequest* request, ::wxhomework::UserRegisterResponse* response);
					virtual ::grpc::Status doPasswordChange(::grpc::ServerContext* context, const ::wxhomework::UserInfoRequest* request, ::wxhomework::UserPasswordChangeResponse* response);
			};
			template <class BaseClass>
			class WithAsyncMethod_doLogin : public BaseClass {
				private:
					void BaseClassMustBeDerivedFromService(const Service *service) {}
				public:
					WithAsyncMethod_doLogin() {
						::grpc::Service::MarkMethodAsync(0);
					}
					~WithAsyncMethod_doLogin() override {
						BaseClassMustBeDerivedFromService(this);
					}
					// disable synchronous version of this method
					::grpc::Status doLogin(::grpc::ServerContext* context, const ::wxhomework::UserInfoRequest* request, ::wxhomework::UserLoginResponse* response) override {
						abort();
						return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
					}
					void RequestdoLogin(::grpc::ServerContext* context, ::wxhomework::UserInfoRequest* request, ::grpc::ServerAsyncResponseWriter< ::wxhomework::UserLoginResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
						::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
					}
			};
			template <class BaseClass>
			class WithAsyncMethod_doLoginOut : public BaseClass {
				private:
					void BaseClassMustBeDerivedFromService(const Service *service) {}
				public:
					WithAsyncMethod_doLoginOut() {
						::grpc::Service::MarkMethodAsync(1);
					}
					~WithAsyncMethod_doLoginOut() override {
						BaseClassMustBeDerivedFromService(this);
					}
					// disable synchronous version of this method
					::grpc::Status doLoginOut(::grpc::ServerContext* context, const ::wxhomework::UserInfoRequest* request, ::wxhomework::UserLoginResponse* response) override {
						abort();
						return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
					}
					void RequestdoLoginOut(::grpc::ServerContext* context, ::wxhomework::UserInfoRequest* request, ::grpc::ServerAsyncResponseWriter< ::wxhomework::UserLoginResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
						::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
					}
			};
			template <class BaseClass>
			class WithAsyncMethod_doRegister : public BaseClass {
				private:
					void BaseClassMustBeDerivedFromService(const Service *service) {}
				public:
					WithAsyncMethod_doRegister() {
						::grpc::Service::MarkMethodAsync(2);
					}
					~WithAsyncMethod_doRegister() override {
						BaseClassMustBeDerivedFromService(this);
					}
					// disable synchronous version of this method
					::grpc::Status doRegister(::grpc::ServerContext* context, const ::wxhomework::UserInfoRequest* request, ::wxhomework::UserRegisterResponse* response) override {
						abort();
						return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
					}
					void RequestdoRegister(::grpc::ServerContext* context, ::wxhomework::UserInfoRequest* request, ::grpc::ServerAsyncResponseWriter< ::wxhomework::UserRegisterResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
						::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
					}
			};
			template <class BaseClass>
			class WithAsyncMethod_doPasswordChange : public BaseClass {
				private:
					void BaseClassMustBeDerivedFromService(const Service *service) {}
				public:
					WithAsyncMethod_doPasswordChange() {
						::grpc::Service::MarkMethodAsync(3);
					}
					~WithAsyncMethod_doPasswordChange() override {
						BaseClassMustBeDerivedFromService(this);
					}
					// disable synchronous version of this method
					::grpc::Status doPasswordChange(::grpc::ServerContext* context, const ::wxhomework::UserInfoRequest* request, ::wxhomework::UserPasswordChangeResponse* response) override {
						abort();
						return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
					}
					void RequestdoPasswordChange(::grpc::ServerContext* context, ::wxhomework::UserInfoRequest* request, ::grpc::ServerAsyncResponseWriter< ::wxhomework::UserPasswordChangeResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
						::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
					}
			};
			typedef WithAsyncMethod_doLogin<WithAsyncMethod_doLoginOut<WithAsyncMethod_doRegister<WithAsyncMethod_doPasswordChange<Service > > > > AsyncService;
			template <class BaseClass>
			class ExperimentalWithCallbackMethod_doLogin : public BaseClass {
				private:
					void BaseClassMustBeDerivedFromService(const Service *service) {}
				public:
					ExperimentalWithCallbackMethod_doLogin() {
						::grpc::Service::experimental().MarkMethodCallback(0,
						        new ::grpc::internal::CallbackUnaryHandler< ::wxhomework::UserInfoRequest, ::wxhomework::UserLoginResponse>(
						            [this](::grpc::ServerContext* context,
						                   const ::wxhomework::UserInfoRequest* request,
						                   ::wxhomework::UserLoginResponse* response,
						::grpc::experimental::ServerCallbackRpcController* controller) {
							return this->doLogin(context, request, response, controller);
						}));
					}
					void SetMessageAllocatorFor_doLogin(
					    ::grpc::experimental::MessageAllocator< ::wxhomework::UserInfoRequest, ::wxhomework::UserLoginResponse>* allocator) {
						static_cast<::grpc::internal::CallbackUnaryHandler< ::wxhomework::UserInfoRequest, ::wxhomework::UserLoginResponse>*>(
						    ::grpc::Service::experimental().GetHandler(0))
						->SetMessageAllocator(allocator);
					}
					~ExperimentalWithCallbackMethod_doLogin() override {
						BaseClassMustBeDerivedFromService(this);
					}
					// disable synchronous version of this method
					::grpc::Status doLogin(::grpc::ServerContext* context, const ::wxhomework::UserInfoRequest* request, ::wxhomework::UserLoginResponse* response) override {
						abort();
						return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
					}
					virtual void doLogin(::grpc::ServerContext* context, const ::wxhomework::UserInfoRequest* request, ::wxhomework::UserLoginResponse* response, ::grpc::experimental::ServerCallbackRpcController* controller) {
						controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, ""));
					}
			};
			template <class BaseClass>
			class ExperimentalWithCallbackMethod_doLoginOut : public BaseClass {
				private:
					void BaseClassMustBeDerivedFromService(const Service *service) {}
				public:
					ExperimentalWithCallbackMethod_doLoginOut() {
						::grpc::Service::experimental().MarkMethodCallback(1,
						        new ::grpc::internal::CallbackUnaryHandler< ::wxhomework::UserInfoRequest, ::wxhomework::UserLoginResponse>(
						            [this](::grpc::ServerContext* context,
						                   const ::wxhomework::UserInfoRequest* request,
						                   ::wxhomework::UserLoginResponse* response,
						::grpc::experimental::ServerCallbackRpcController* controller) {
							return this->doLoginOut(context, request, response, controller);
						}));
					}
					void SetMessageAllocatorFor_doLoginOut(
					    ::grpc::experimental::MessageAllocator< ::wxhomework::UserInfoRequest, ::wxhomework::UserLoginResponse>* allocator) {
						static_cast<::grpc::internal::CallbackUnaryHandler< ::wxhomework::UserInfoRequest, ::wxhomework::UserLoginResponse>*>(
						    ::grpc::Service::experimental().GetHandler(1))
						->SetMessageAllocator(allocator);
					}
					~ExperimentalWithCallbackMethod_doLoginOut() override {
						BaseClassMustBeDerivedFromService(this);
					}
					// disable synchronous version of this method
					::grpc::Status doLoginOut(::grpc::ServerContext* context, const ::wxhomework::UserInfoRequest* request, ::wxhomework::UserLoginResponse* response) override {
						abort();
						return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
					}
					virtual void doLoginOut(::grpc::ServerContext* context, const ::wxhomework::UserInfoRequest* request, ::wxhomework::UserLoginResponse* response, ::grpc::experimental::ServerCallbackRpcController* controller) {
						controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, ""));
					}
			};
			template <class BaseClass>
			class ExperimentalWithCallbackMethod_doRegister : public BaseClass {
				private:
					void BaseClassMustBeDerivedFromService(const Service *service) {}
				public:
					ExperimentalWithCallbackMethod_doRegister() {
						::grpc::Service::experimental().MarkMethodCallback(2,
						        new ::grpc::internal::CallbackUnaryHandler< ::wxhomework::UserInfoRequest, ::wxhomework::UserRegisterResponse>(
						            [this](::grpc::ServerContext* context,
						                   const ::wxhomework::UserInfoRequest* request,
						                   ::wxhomework::UserRegisterResponse* response,
						::grpc::experimental::ServerCallbackRpcController* controller) {
							return this->doRegister(context, request, response, controller);
						}));
					}
					void SetMessageAllocatorFor_doRegister(
					    ::grpc::experimental::MessageAllocator< ::wxhomework::UserInfoRequest, ::wxhomework::UserRegisterResponse>* allocator) {
						static_cast<::grpc::internal::CallbackUnaryHandler< ::wxhomework::UserInfoRequest, ::wxhomework::UserRegisterResponse>*>(
						    ::grpc::Service::experimental().GetHandler(2))
						->SetMessageAllocator(allocator);
					}
					~ExperimentalWithCallbackMethod_doRegister() override {
						BaseClassMustBeDerivedFromService(this);
					}
					// disable synchronous version of this method
					::grpc::Status doRegister(::grpc::ServerContext* context, const ::wxhomework::UserInfoRequest* request, ::wxhomework::UserRegisterResponse* response) override {
						abort();
						return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
					}
					virtual void doRegister(::grpc::ServerContext* context, const ::wxhomework::UserInfoRequest* request, ::wxhomework::UserRegisterResponse* response, ::grpc::experimental::ServerCallbackRpcController* controller) {
						controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, ""));
					}
			};
			template <class BaseClass>
			class ExperimentalWithCallbackMethod_doPasswordChange : public BaseClass {
				private:
					void BaseClassMustBeDerivedFromService(const Service *service) {}
				public:
					ExperimentalWithCallbackMethod_doPasswordChange() {
						::grpc::Service::experimental().MarkMethodCallback(3,
						        new ::grpc::internal::CallbackUnaryHandler< ::wxhomework::UserInfoRequest, ::wxhomework::UserPasswordChangeResponse>(
						            [this](::grpc::ServerContext* context,
						                   const ::wxhomework::UserInfoRequest* request,
						                   ::wxhomework::UserPasswordChangeResponse* response,
						::grpc::experimental::ServerCallbackRpcController* controller) {
							return this->doPasswordChange(context, request, response, controller);
						}));
					}
					void SetMessageAllocatorFor_doPasswordChange(
					    ::grpc::experimental::MessageAllocator< ::wxhomework::UserInfoRequest, ::wxhomework::UserPasswordChangeResponse>* allocator) {
						static_cast<::grpc::internal::CallbackUnaryHandler< ::wxhomework::UserInfoRequest, ::wxhomework::UserPasswordChangeResponse>*>(
						    ::grpc::Service::experimental().GetHandler(3))
						->SetMessageAllocator(allocator);
					}
					~ExperimentalWithCallbackMethod_doPasswordChange() override {
						BaseClassMustBeDerivedFromService(this);
					}
					// disable synchronous version of this method
					::grpc::Status doPasswordChange(::grpc::ServerContext* context, const ::wxhomework::UserInfoRequest* request, ::wxhomework::UserPasswordChangeResponse* response) override {
						abort();
						return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
					}
					virtual void doPasswordChange(::grpc::ServerContext* context, const ::wxhomework::UserInfoRequest* request, ::wxhomework::UserPasswordChangeResponse* response, ::grpc::experimental::ServerCallbackRpcController* controller) {
						controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, ""));
					}
			};
			typedef ExperimentalWithCallbackMethod_doLogin<ExperimentalWithCallbackMethod_doLoginOut<ExperimentalWithCallbackMethod_doRegister<ExperimentalWithCallbackMethod_doPasswordChange<Service > > > > ExperimentalCallbackService;
			template <class BaseClass>
			class WithGenericMethod_doLogin : public BaseClass {
				private:
					void BaseClassMustBeDerivedFromService(const Service *service) {}
				public:
					WithGenericMethod_doLogin() {
						::grpc::Service::MarkMethodGeneric(0);
					}
					~WithGenericMethod_doLogin() override {
						BaseClassMustBeDerivedFromService(this);
					}
					// disable synchronous version of this method
					::grpc::Status doLogin(::grpc::ServerContext* context, const ::wxhomework::UserInfoRequest* request, ::wxhomework::UserLoginResponse* response) override {
						abort();
						return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
					}
			};
			template <class BaseClass>
			class WithGenericMethod_doLoginOut : public BaseClass {
				private:
					void BaseClassMustBeDerivedFromService(const Service *service) {}
				public:
					WithGenericMethod_doLoginOut() {
						::grpc::Service::MarkMethodGeneric(1);
					}
					~WithGenericMethod_doLoginOut() override {
						BaseClassMustBeDerivedFromService(this);
					}
					// disable synchronous version of this method
					::grpc::Status doLoginOut(::grpc::ServerContext* context, const ::wxhomework::UserInfoRequest* request, ::wxhomework::UserLoginResponse* response) override {
						abort();
						return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
					}
			};
			template <class BaseClass>
			class WithGenericMethod_doRegister : public BaseClass {
				private:
					void BaseClassMustBeDerivedFromService(const Service *service) {}
				public:
					WithGenericMethod_doRegister() {
						::grpc::Service::MarkMethodGeneric(2);
					}
					~WithGenericMethod_doRegister() override {
						BaseClassMustBeDerivedFromService(this);
					}
					// disable synchronous version of this method
					::grpc::Status doRegister(::grpc::ServerContext* context, const ::wxhomework::UserInfoRequest* request, ::wxhomework::UserRegisterResponse* response) override {
						abort();
						return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
					}
			};
			template <class BaseClass>
			class WithGenericMethod_doPasswordChange : public BaseClass {
				private:
					void BaseClassMustBeDerivedFromService(const Service *service) {}
				public:
					WithGenericMethod_doPasswordChange() {
						::grpc::Service::MarkMethodGeneric(3);
					}
					~WithGenericMethod_doPasswordChange() override {
						BaseClassMustBeDerivedFromService(this);
					}
					// disable synchronous version of this method
					::grpc::Status doPasswordChange(::grpc::ServerContext* context, const ::wxhomework::UserInfoRequest* request, ::wxhomework::UserPasswordChangeResponse* response) override {
						abort();
						return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
					}
			};
			template <class BaseClass>
			class WithRawMethod_doLogin : public BaseClass {
				private:
					void BaseClassMustBeDerivedFromService(const Service *service) {}
				public:
					WithRawMethod_doLogin() {
						::grpc::Service::MarkMethodRaw(0);
					}
					~WithRawMethod_doLogin() override {
						BaseClassMustBeDerivedFromService(this);
					}
					// disable synchronous version of this method
					::grpc::Status doLogin(::grpc::ServerContext* context, const ::wxhomework::UserInfoRequest* request, ::wxhomework::UserLoginResponse* response) override {
						abort();
						return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
					}
					void RequestdoLogin(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
						::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
					}
			};
			template <class BaseClass>
			class WithRawMethod_doLoginOut : public BaseClass {
				private:
					void BaseClassMustBeDerivedFromService(const Service *service) {}
				public:
					WithRawMethod_doLoginOut() {
						::grpc::Service::MarkMethodRaw(1);
					}
					~WithRawMethod_doLoginOut() override {
						BaseClassMustBeDerivedFromService(this);
					}
					// disable synchronous version of this method
					::grpc::Status doLoginOut(::grpc::ServerContext* context, const ::wxhomework::UserInfoRequest* request, ::wxhomework::UserLoginResponse* response) override {
						abort();
						return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
					}
					void RequestdoLoginOut(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
						::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
					}
			};
			template <class BaseClass>
			class WithRawMethod_doRegister : public BaseClass {
				private:
					void BaseClassMustBeDerivedFromService(const Service *service) {}
				public:
					WithRawMethod_doRegister() {
						::grpc::Service::MarkMethodRaw(2);
					}
					~WithRawMethod_doRegister() override {
						BaseClassMustBeDerivedFromService(this);
					}
					// disable synchronous version of this method
					::grpc::Status doRegister(::grpc::ServerContext* context, const ::wxhomework::UserInfoRequest* request, ::wxhomework::UserRegisterResponse* response) override {
						abort();
						return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
					}
					void RequestdoRegister(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
						::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
					}
			};
			template <class BaseClass>
			class WithRawMethod_doPasswordChange : public BaseClass {
				private:
					void BaseClassMustBeDerivedFromService(const Service *service) {}
				public:
					WithRawMethod_doPasswordChange() {
						::grpc::Service::MarkMethodRaw(3);
					}
					~WithRawMethod_doPasswordChange() override {
						BaseClassMustBeDerivedFromService(this);
					}
					// disable synchronous version of this method
					::grpc::Status doPasswordChange(::grpc::ServerContext* context, const ::wxhomework::UserInfoRequest* request, ::wxhomework::UserPasswordChangeResponse* response) override {
						abort();
						return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
					}
					void RequestdoPasswordChange(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
						::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
					}
			};
			template <class BaseClass>
			class ExperimentalWithRawCallbackMethod_doLogin : public BaseClass {
				private:
					void BaseClassMustBeDerivedFromService(const Service *service) {}
				public:
					ExperimentalWithRawCallbackMethod_doLogin() {
						::grpc::Service::experimental().MarkMethodRawCallback(0,
						        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
						            [this](::grpc::ServerContext* context,
						                   const ::grpc::ByteBuffer* request,
						                   ::grpc::ByteBuffer* response,
						::grpc::experimental::ServerCallbackRpcController* controller) {
							this->doLogin(context, request, response, controller);
						}));
					}
					~ExperimentalWithRawCallbackMethod_doLogin() override {
						BaseClassMustBeDerivedFromService(this);
					}
					// disable synchronous version of this method
					::grpc::Status doLogin(::grpc::ServerContext* context, const ::wxhomework::UserInfoRequest* request, ::wxhomework::UserLoginResponse* response) override {
						abort();
						return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
					}
					virtual void doLogin(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) {
						controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, ""));
					}
			};
			template <class BaseClass>
			class ExperimentalWithRawCallbackMethod_doLoginOut : public BaseClass {
				private:
					void BaseClassMustBeDerivedFromService(const Service *service) {}
				public:
					ExperimentalWithRawCallbackMethod_doLoginOut() {
						::grpc::Service::experimental().MarkMethodRawCallback(1,
						        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
						            [this](::grpc::ServerContext* context,
						                   const ::grpc::ByteBuffer* request,
						                   ::grpc::ByteBuffer* response,
						::grpc::experimental::ServerCallbackRpcController* controller) {
							this->doLoginOut(context, request, response, controller);
						}));
					}
					~ExperimentalWithRawCallbackMethod_doLoginOut() override {
						BaseClassMustBeDerivedFromService(this);
					}
					// disable synchronous version of this method
					::grpc::Status doLoginOut(::grpc::ServerContext* context, const ::wxhomework::UserInfoRequest* request, ::wxhomework::UserLoginResponse* response) override {
						abort();
						return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
					}
					virtual void doLoginOut(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) {
						controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, ""));
					}
			};
			template <class BaseClass>
			class ExperimentalWithRawCallbackMethod_doRegister : public BaseClass {
				private:
					void BaseClassMustBeDerivedFromService(const Service *service) {}
				public:
					ExperimentalWithRawCallbackMethod_doRegister() {
						::grpc::Service::experimental().MarkMethodRawCallback(2,
						        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
						            [this](::grpc::ServerContext* context,
						                   const ::grpc::ByteBuffer* request,
						                   ::grpc::ByteBuffer* response,
						::grpc::experimental::ServerCallbackRpcController* controller) {
							this->doRegister(context, request, response, controller);
						}));
					}
					~ExperimentalWithRawCallbackMethod_doRegister() override {
						BaseClassMustBeDerivedFromService(this);
					}
					// disable synchronous version of this method
					::grpc::Status doRegister(::grpc::ServerContext* context, const ::wxhomework::UserInfoRequest* request, ::wxhomework::UserRegisterResponse* response) override {
						abort();
						return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
					}
					virtual void doRegister(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) {
						controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, ""));
					}
			};
			template <class BaseClass>
			class ExperimentalWithRawCallbackMethod_doPasswordChange : public BaseClass {
				private:
					void BaseClassMustBeDerivedFromService(const Service *service) {}
				public:
					ExperimentalWithRawCallbackMethod_doPasswordChange() {
						::grpc::Service::experimental().MarkMethodRawCallback(3,
						        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
						            [this](::grpc::ServerContext* context,
						                   const ::grpc::ByteBuffer* request,
						                   ::grpc::ByteBuffer* response,
						::grpc::experimental::ServerCallbackRpcController* controller) {
							this->doPasswordChange(context, request, response, controller);
						}));
					}
					~ExperimentalWithRawCallbackMethod_doPasswordChange() override {
						BaseClassMustBeDerivedFromService(this);
					}
					// disable synchronous version of this method
					::grpc::Status doPasswordChange(::grpc::ServerContext* context, const ::wxhomework::UserInfoRequest* request, ::wxhomework::UserPasswordChangeResponse* response) override {
						abort();
						return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
					}
					virtual void doPasswordChange(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) {
						controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, ""));
					}
			};
			template <class BaseClass>
			class WithStreamedUnaryMethod_doLogin : public BaseClass {
				private:
					void BaseClassMustBeDerivedFromService(const Service *service) {}
				public:
					WithStreamedUnaryMethod_doLogin() {
						::grpc::Service::MarkMethodStreamed(0,
						                                    new ::grpc::internal::StreamedUnaryHandler< ::wxhomework::UserInfoRequest, ::wxhomework::UserLoginResponse>(std::bind(&WithStreamedUnaryMethod_doLogin<BaseClass>::StreameddoLogin, this, std::placeholders::_1, std::placeholders::_2)));
					}
					~WithStreamedUnaryMethod_doLogin() override {
						BaseClassMustBeDerivedFromService(this);
					}
					// disable regular version of this method
					::grpc::Status doLogin(::grpc::ServerContext* context, const ::wxhomework::UserInfoRequest* request, ::wxhomework::UserLoginResponse* response) override {
						abort();
						return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
					}
					// replace default version of method with streamed unary
					virtual ::grpc::Status StreameddoLogin(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::wxhomework::UserInfoRequest,::wxhomework::UserLoginResponse>* server_unary_streamer) = 0;
			};
			template <class BaseClass>
			class WithStreamedUnaryMethod_doLoginOut : public BaseClass {
				private:
					void BaseClassMustBeDerivedFromService(const Service *service) {}
				public:
					WithStreamedUnaryMethod_doLoginOut() {
						::grpc::Service::MarkMethodStreamed(1,
						                                    new ::grpc::internal::StreamedUnaryHandler< ::wxhomework::UserInfoRequest, ::wxhomework::UserLoginResponse>(std::bind(&WithStreamedUnaryMethod_doLoginOut<BaseClass>::StreameddoLoginOut, this, std::placeholders::_1, std::placeholders::_2)));
					}
					~WithStreamedUnaryMethod_doLoginOut() override {
						BaseClassMustBeDerivedFromService(this);
					}
					// disable regular version of this method
					::grpc::Status doLoginOut(::grpc::ServerContext* context, const ::wxhomework::UserInfoRequest* request, ::wxhomework::UserLoginResponse* response) override {
						abort();
						return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
					}
					// replace default version of method with streamed unary
					virtual ::grpc::Status StreameddoLoginOut(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::wxhomework::UserInfoRequest,::wxhomework::UserLoginResponse>* server_unary_streamer) = 0;
			};
			template <class BaseClass>
			class WithStreamedUnaryMethod_doRegister : public BaseClass {
				private:
					void BaseClassMustBeDerivedFromService(const Service *service) {}
				public:
					WithStreamedUnaryMethod_doRegister() {
						::grpc::Service::MarkMethodStreamed(2,
						                                    new ::grpc::internal::StreamedUnaryHandler< ::wxhomework::UserInfoRequest, ::wxhomework::UserRegisterResponse>(std::bind(&WithStreamedUnaryMethod_doRegister<BaseClass>::StreameddoRegister, this, std::placeholders::_1, std::placeholders::_2)));
					}
					~WithStreamedUnaryMethod_doRegister() override {
						BaseClassMustBeDerivedFromService(this);
					}
					// disable regular version of this method
					::grpc::Status doRegister(::grpc::ServerContext* context, const ::wxhomework::UserInfoRequest* request, ::wxhomework::UserRegisterResponse* response) override {
						abort();
						return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
					}
					// replace default version of method with streamed unary
					virtual ::grpc::Status StreameddoRegister(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::wxhomework::UserInfoRequest,::wxhomework::UserRegisterResponse>* server_unary_streamer) = 0;
			};
			template <class BaseClass>
			class WithStreamedUnaryMethod_doPasswordChange : public BaseClass {
				private:
					void BaseClassMustBeDerivedFromService(const Service *service) {}
				public:
					WithStreamedUnaryMethod_doPasswordChange() {
						::grpc::Service::MarkMethodStreamed(3,
						                                    new ::grpc::internal::StreamedUnaryHandler< ::wxhomework::UserInfoRequest, ::wxhomework::UserPasswordChangeResponse>(std::bind(&WithStreamedUnaryMethod_doPasswordChange<BaseClass>::StreameddoPasswordChange, this, std::placeholders::_1, std::placeholders::_2)));
					}
					~WithStreamedUnaryMethod_doPasswordChange() override {
						BaseClassMustBeDerivedFromService(this);
					}
					// disable regular version of this method
					::grpc::Status doPasswordChange(::grpc::ServerContext* context, const ::wxhomework::UserInfoRequest* request, ::wxhomework::UserPasswordChangeResponse* response) override {
						abort();
						return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
					}
					// replace default version of method with streamed unary
					virtual ::grpc::Status StreameddoPasswordChange(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::wxhomework::UserInfoRequest,::wxhomework::UserPasswordChangeResponse>* server_unary_streamer) = 0;
			};
			typedef WithStreamedUnaryMethod_doLogin<WithStreamedUnaryMethod_doLoginOut<WithStreamedUnaryMethod_doRegister<WithStreamedUnaryMethod_doPasswordChange<Service > > > > StreamedUnaryService;
			typedef Service SplitStreamedService;
			typedef WithStreamedUnaryMethod_doLogin<WithStreamedUnaryMethod_doLoginOut<WithStreamedUnaryMethod_doRegister<WithStreamedUnaryMethod_doPasswordChange<Service > > > > StreamedService;
	};

}  // namespace wxhomework


#endif  // GRPC_src_2fmain_2fproto_2fwxhomework_2eproto__INCLUDED
